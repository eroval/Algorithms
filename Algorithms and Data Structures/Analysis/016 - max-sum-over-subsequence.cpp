/* Намиране на най-дълга ненамаляваща подредица (от не непременно съседни числа) на дадена
   числова редица. Дължината на такава подредица очевидно е еднозначно определена от редицата,
   но самата подредица може да не е единствена. Броят на извършваните от програмата действия
   е пропорционален на n . log n. Например за редицата 
        8 5 4 2 9 8 3 8 6 2 9 2
   се извежда
        [4] = 2  [7] = 3  [9] = 6  [11] = 9 .
   (Подредицата се състои от числата с последователни номера в редицата 4, 7, 9 и 11, а именно
   2, 3, 6 и 9. За дадената редица най-дълги ненамаляващи подредици са също 4 8 8 9 и 5 8 8 9.)
   Даденото тук решение може да се преправи така, че числата да се четат последователно без
   съхраняване на редицата. Тогава в b[] и (*u)[] трябва да се записват не индекси, а самите
   стойности от редицата.
   Може също да се разглежда редица от какви да е стойности, за които е определено отношение
   на предшестване – обобщение на отношението ≤ между числа.
   Виж също https://en.wikipedia.org/wiki/Longest_increasing_subsequence. */

#include <iostream>
#include <vector>

using namespace std;

void liss(vector<int> & a, vector<int> & b) {
  int n = a.size(), k = 1;
  b.clear();
  vector<int> * u = new vector<int>(n);
  b.push_back(0);
  for (int i = 1; i < n; ++i) {
// i       = индексът (от 0) на текущо разглежданата стойност от редицата
// k       = най-голямата възможна дължина на ненамаляваща подредица от стойностите с индекси ≤ i
// b[j]    = индекс на най-малката възможна последна стойност на ненамаляваща подредица с дължина j+1 (за всяко 0 ≤ j < k)
// (*u)[j] = индекс на стойност преди j-та в редицата и не по-голяма от нея (за тези 0 ≤ j ≤ i, за които такава стойност има)
    int t = a[i];
    if (t < a[b[0]])
      b[0] = i;
    else if (a[b[k-1]] <= t) {
      b.push_back(i);
      (*u)[i] = b[k-1];
      ++k;
    } else {    // k > 1
      int p = 0, q = k-1;
      for (;;) {        // стесняване на дължината на [p,q] до 2, спазвайки a[b[p]] ≤ t < a[b[q]]
        int h = q-p+1;
        if (h == 2) break;
        int m = p+h/2;
        (a[b[m]] <= t ? p : q) = m;
      }
      b[q] = i;
      (*u)[i] = b[p];
    }
  }
  for (int i = k-2; i >= 0; --i)    // намиране на индексите на числата от подредицата
    b[i] = (*u)[b[i+1]];
  delete u;
}

int main() {
  vector<int> a, b;
  for (int x; cin >> x;) a.push_back(x);
  liss(a,b);
  for (auto i : b)
    cout << '[' << (i+1) << "] = " << a[i] << "  ";
  cout << endl;
}
